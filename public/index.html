<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket Live Tracker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #333;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 150px;
        }
        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .market-table {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .status-active {
            color: green;
            font-weight: bold;
        }
        .status-resolved {
            color: red;
            font-weight: bold;
        }
        .market-name {
            font-weight: bold;
            color: #333;
        }
        .market-link {
            color: #0066cc;
            text-decoration: none;
        }
        .market-link:hover {
            text-decoration: underline;
        }
        .outcomes {
            font-size: 12px;
            color: #666;
        }
        .multi-outcome {
            background-color: #fff3cd;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .update-time {
            color: #666;
            font-size: 12px;
        }
        .filter-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.active {
            background-color: #28a745;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .countdown {
            font-size: 11px;
            font-weight: 500;
            margin-top: 2px;
            padding: 2px 4px;
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.1);
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Polymarket Live Tracker</h1>
        <p class="update-time" id="lastUpdate">Loading...</p>
        <p class="countdown-time" id="countdownTimer" style="color: #28a745; font-weight: bold; margin-top: 5px;">‚è∞ Next update in: --:--</p>
    </div>

    <div class="stats" id="stats">
        <div class="stat-card">
            <h3>Total Events</h3>
            <div id="totalEvents">-</div>
        </div>
        <div class="stat-card">
            <h3>Active Events</h3>
            <div id="activeEvents">-</div>
        </div>
        <div class="stat-card">
            <h3>Total Markets</h3>
            <div id="totalMarkets">-</div>
        </div>
        <div class="stat-card">
            <h3>Resolved Markets</h3>
            <div id="resolvedMarkets">-</div>
        </div>
        <div class="stat-card">
            <h3>Total Volume</h3>
            <div id="totalVolumeDisplay">-</div>
        </div>
        <div class="stat-card">
            <h3>Hidden Markets</h3>
            <div id="hiddenMarkets">-</div>
            <small style="color: #666; font-size: 10px;">0 volume</small>
        </div>
    </div>

    <div class="stats" id="winnerStats" style="display: none;">
        <div class="stat-card">
            <h3>üèÜ Winner Stats</h3>
            <div id="totalWinners">-</div>
            <small style="color: #666; font-size: 10px;">total winners</small>
        </div>
        <div class="stat-card">
            <h3>üí∞ Total Payouts</h3>
            <div id="totalPayouts">-</div>
            <small style="color: #666; font-size: 10px;">USDC paid</small>
        </div>
        <div class="stat-card">
            <h3>üìä Markets Tracked</h3>
            <div id="marketsTracked">-</div>
            <small style="color: #666; font-size: 10px;">resolved markets</small>
        </div>
        <div class="stat-card">
            <h3>ü•á Top Winner</h3>
            <div id="topWinner">-</div>
            <small style="color: #666; font-size: 10px;">highest payout</small>
        </div>
    </div>

    <div class="controls">
        <div class="filter-controls">
            <input type="text" id="searchInput" placeholder="Search events..." onkeyup="filterMarkets()">
            
            <select id="limitSelect" onchange="loadMarkets()">
                <option value="50">50 events</option>
                <option value="100">100 events</option>
                <option value="250">250 events</option>
                <option value="500">500 events</option>
            </select>
            
            <select id="sortSelect" onchange="sortEvents()">
                <option value="volume">Sort by Volume</option>
                <option value="endDate">Sort by End Date</option>
            </select>
            
            <button onclick="loadMarkets()" style="background-color: #17a2b8;">üîÑ Refresh</button>
            <button onclick="triggerUpdate()" style="background-color: #ffc107; color: black;">‚ö° Force Update</button>
            <button onclick="toggleWinnerView()" style="background-color: #28a745; color: white;">üèÜ Winners</button>
            <button onclick="showMarketIds()" style="background-color: #6f42c1; color: white;">üìã Market IDs</button>
        </div>
    </div>

    <div class="market-table">
        <table>
            <thead>
                <tr>
                    <th>Event Title</th>
                    <th>Markets</th>
                </tr>
            </thead>
            <tbody id="marketsTable">
                <tr>
                    <td colspan="3" class="loading">Loading markets...</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
        let currentFilter = 'active';
        let allMarkets = [];
        let eventSource = null;

        async function loadStats() {
            try {
                const response = await fetch('/stats');
                const stats = await response.json();
                
                document.getElementById('totalEvents').textContent = stats.totalEvents.toLocaleString();
                document.getElementById('activeEvents').textContent = stats.events.active.toLocaleString();
                document.getElementById('totalMarkets').textContent = stats.markets.total.toLocaleString();
                document.getElementById('resolvedMarkets').textContent = (stats.markets.resolved || 0).toLocaleString();
                document.getElementById('totalVolumeDisplay').textContent = '$' + (stats.totalVolume || 0).toLocaleString();
                
                if (stats.lastUpdate) {
                    document.getElementById('lastUpdate').textContent = 
                        `Last updated: ${new Date(stats.lastUpdate).toLocaleString()}`;
                } else {
                    document.getElementById('lastUpdate').textContent = 
                        `Last updated: ${new Date().toLocaleString()}`;
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadMarkets() {
            const limitSelect = document.getElementById('limitSelect');
            const limit = limitSelect ? limitSelect.value : 50;
            
            try {
                console.log('Fetching events...');
                const response = await fetch(`/active?limit=${limit}`);
                const data = await response.json();
                console.log('API Response:', data);
                
                allMarkets = data.events || [];
                console.log('Events loaded:', allMarkets.length);
                
                if (allMarkets.length === 0) {
                    document.getElementById('marketsTable').innerHTML = 
                        '<tr><td colspan="2" class="loading">No events found</td></tr>';
                    return;
                }
                
                // Display markets sorted by volume by default
                displayMarkets(sortEvents(allMarkets));
            } catch (error) {
                console.error('Error loading events:', error);
                document.getElementById('marketsTable').innerHTML = 
                    '<tr><td colspan="2" class="loading">Error loading events: ' + error.message + '</td></tr>';
            }
        }

        let totalHiddenMarkets = 0; // Global counter for hidden markets

        function displayMarkets(events) {
            const tbody = document.getElementById('marketsTable');
            
            if (!events || events.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="loading">No events found</td></tr>';
                return;
            }

            totalHiddenMarkets = 0; // Reset counter

            tbody.innerHTML = events.map(event => {
                const hasMultiOutcome = event.multiOutcomeMarketsCount > 0;
                
                const startDate = event.startDate ? new Date(event.startDate).toLocaleDateString() : '-';
                const endDate = event.endDate ? new Date(event.endDate).toLocaleDateString() : '-';
                
                const volume = event.totalVolume ? `$${event.totalVolume.toLocaleString()}` : '$0';
                
                // Generate markets list - filter out 0 volume and sort by volume descending
                const allMarkets = [...event.markets];
                const marketsWithVolume = allMarkets.filter(market => {
                    const marketVolume = market.volumeUSD || market.volume || 0;
                    return marketVolume > 0;
                });
                const hiddenMarketsCount = allMarkets.length - marketsWithVolume.length;
                
                const sortedMarkets = marketsWithVolume.sort((a, b) => {
                    const aVolume = a.volumeUSD || a.volume || 0;
                    const bVolume = b.volumeUSD || b.volume || 0;
                    return bVolume - aVolume;
                });
                const marketsHtml = sortedMarkets.map(market => {
                    let outcomes = [];
                    try {
                        outcomes = market.outcomes ? JSON.parse(market.outcomes) : [];
                    } catch (e) {
                        outcomes = Array.isArray(market.outcomes) ? market.outcomes : [];
                    }
                    const outcomesText = outcomes.length > 0 ? 
                        outcomes.join(', ') : 
                        (market.outcomesCount > 0 ? `${market.outcomesCount} outcomes` : 'Binary');
                    
                    const marketVolume = market.volumeUSD || market.volume || 0;
                    const isResolved = market.active === false || market.closed === true;
                    
                    // Determine winning outcome
                    let winningOutcome = market.winningOutcome;
                    if (isResolved && !winningOutcome && market.outcomePrices) {
                        try {
                            const prices = JSON.parse(market.outcomePrices);
                            if (Array.isArray(prices) && prices.length > 0) {
                                // Find the outcome with the highest price (closest to 1.0)
                                const maxPriceIndex = prices.indexOf(Math.max(...prices.map(p => parseFloat(p))));
                                if (maxPriceIndex >= 0 && outcomes.length > maxPriceIndex) {
                                    winningOutcome = outcomes[maxPriceIndex];
                                } else if (prices.length === 2) {
                                    // For binary markets, use Yes/No
                                    winningOutcome = parseFloat(prices[0]) > parseFloat(prices[1]) ? 'Yes' : 'No';
                                }
                            }
                        } catch (e) {
                            // Ignore parsing errors
                        }
                    }
                    
                    let volumeColor, backgroundColor, statusText;
                    if (isResolved) {
                        volumeColor = '#dc3545'; // Red for resolved
                        backgroundColor = '#ffe6e6';
                        statusText = ' (RESOLVED)';
                    } else {
                        volumeColor = marketVolume > 100000 ? '#28a745' : marketVolume > 10000 ? '#ffc107' : '#6c757d';
                        backgroundColor = '#f8f9fa';
                        statusText = '';
                    }

                    return `
                        <div style="margin: 6px 0; padding: 8px; border-left: 4px solid ${volumeColor}; background: ${backgroundColor}; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <strong style="flex: 1; font-size: 14px;">${market.question}${statusText}</strong>
                                <span style="font-weight: bold; font-size: 16px; color: ${volumeColor};">$${marketVolume.toLocaleString()}</span>
                            </div>
                            <div style="font-size: 10px; color: #6c757d; margin-top: 4px; font-family: monospace; display: flex; align-items: center; gap: 8px;">
                                <span>Market ID: ${market.id || market.conditionId || 'N/A'}</span>
                                ${isResolved && winningOutcome ? 
                                    `<div style="padding: 2px 6px; background: #28a745; color: white; border-radius: 8px; font-size: 9px; font-weight: bold;">
                                        üèÜ Winner: ${winningOutcome}
                                    </div>` : isResolved ? 
                                    `<div style="padding: 2px 6px; background: #6c757d; color: white; border-radius: 8px; font-size: 9px; font-weight: bold;">
                                        ‚úÖ RESOLVED
                                    </div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add to global hidden markets count
                totalHiddenMarkets += hiddenMarketsCount;
                
                return `
                    <tr class="${hasMultiOutcome ? 'multi-outcome' : ''}">
                        <td>
                            <div class="market-name">
                                ${event.title}
                                ${event.slug ? 
                                    `<a href="https://polymarket.com/event/${event.slug}" target="_blank" style="margin-left: 8px; color: #0066cc; text-decoration: none;" title="Open in Polymarket">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M14 3V5H17.59L7.76 14.83L9.17 16.24L19 6.41V10H21V3M19 19H5V5H12V3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V12H19V19Z" fill="#0066cc"/>
                                        </svg>
                                    </a>` : 
                                    ''
                                }
                            </div>
                            <div style="font-size: 14px; color: #28a745; font-weight: bold; margin: 4px 0;">
                                üí∞ ${volume}
                            </div>
                            <div style="font-size: 12px; color: #666;">
                                Slug: ${event.slug || 'N/A'}
                            </div>
                            <div style="font-size: 12px; color: #007bff; font-weight: 500; margin-top: 2px;">
                                üìã Event ID: <span style="font-family: monospace; background: #f8f9fa; padding: 1px 4px; border-radius: 3px;">${event.id || 'N/A'}</span>
                            </div>
                            <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                Start: ${startDate} | End: ${endDate}
                            </div>
                            ${event.endDate ? `<div class="countdown" data-end-date="${event.endDate}" style="margin-top: 6px;">Loading...</div>` : ''}
                        </td>
                        <td>
                            <strong>Total Markets: ${(event.activeMarketsCount || 0) + (event.resolvedMarketsCount || 0)}</strong>
                            <br><small>${event.activeMarketsCount || 0} active, ${event.resolvedMarketsCount || 0} resolved</small>
                            <br><small>${sortedMarkets.length} shown${hiddenMarketsCount > 0 ? `, ${hiddenMarketsCount} hidden (0 volume)` : ''}</small>
                            <div style="max-height: 200px; overflow-y: auto; margin-top: 8px;">
                                ${marketsHtml}
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Start countdown timers after displaying markets
            updateCountdowns();
            
            // Update hidden markets count in stats
            document.getElementById('hiddenMarkets').textContent = totalHiddenMarkets.toLocaleString();
        }

        function updateCountdowns() {
            const countdownElements = document.querySelectorAll('.countdown');
            
            countdownElements.forEach(element => {
                const endDate = element.getAttribute('data-end-date');
                if (!endDate) return;
                
                const targetTime = new Date(endDate).getTime();
                const now = new Date().getTime();
                const difference = targetTime - now;
                
                if (difference > 0) {
                    const days = Math.floor(difference / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((difference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((difference % (1000 * 60)) / 1000);
                    
                    let countdownText = '';
                    if (days > 0) {
                        countdownText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
                    } else if (hours > 0) {
                        countdownText = `${hours}h ${minutes}m ${seconds}s`;
                    } else if (minutes > 0) {
                        countdownText = `${minutes}m ${seconds}s`;
                    } else {
                        countdownText = `${seconds}s`;
                    }
                    
                    element.textContent = countdownText;
                    element.style.color = difference < 3600000 ? '#e74c3c' : '#f39c12'; // Red if < 1 hour, orange otherwise
                } else {
                    element.textContent = '‚è∞ EXPIRED';
                    element.style.color = '#95a5a6';
                }
            });
        }

        function setFilter(filter) {
            currentFilter = filter;
            
            // Update button states
            document.querySelectorAll('.filter-controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (filter === 'active') document.getElementById('showActive').classList.add('active');
            else if (filter === 'resolved') document.getElementById('showResolved').classList.add('active');
            else if (filter === 'all') document.getElementById('showAll').classList.add('active');
            
            loadMarkets();
        }

        function filterMarkets() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            if (!searchTerm) {
                displayMarkets(sortEvents(allMarkets));
                return;
            }
            
            const filtered = allMarkets.filter(event => 
                (event.title || '').toLowerCase().includes(searchTerm) ||
                (event.slug || '').toLowerCase().includes(searchTerm)
            );
            
            displayMarkets(sortEvents(filtered));
        }

        function sortEvents(eventsToSort = allMarkets) {
            const sortSelect = document.getElementById('sortSelect');
            const sortBy = sortSelect ? sortSelect.value : 'volume';
            const sorted = [...eventsToSort];
            
            if (sortBy === 'volume') {
                sorted.sort((a, b) => b.totalVolume - a.totalVolume);
            } else if (sortBy === 'endDate') {
                sorted.sort((a, b) => {
                    if (!a.endDate && !b.endDate) return 0;
                    if (!a.endDate) return 1;
                    if (!b.endDate) return -1;
                    return new Date(a.endDate) - new Date(b.endDate);
                });
            }
            
            // If this is called directly from the dropdown (not as a helper), update the display
            if (eventsToSort === allMarkets) {
                displayMarkets(sorted);
            }
            
            return sorted;
        }


        async function triggerUpdate() {
            try {
                await fetch('/update');
                setTimeout(() => {
                    loadStats();
                    loadMarkets();
                }, 2000);
            } catch (error) {
                console.error('Error triggering update:', error);
            }
        }

        function connectToSSE() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/events');

            eventSource.onopen = function() {
                console.log('üîó Connected to real-time updates');
                document.getElementById('lastUpdate').textContent += ' (Real-time connected ‚úÖ)';
            };

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleRealtimeUpdate(data);
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            eventSource.onerror = function(error) {
                console.log('‚ùå SSE connection error, reconnecting in 5 seconds...');
                setTimeout(() => connectToSSE(), 5000);
            };
        }

        function handleRealtimeUpdate(data) {
            console.log('üì° Real-time update received:', data);

            if (data.type === 'market_resolved') {
                // Find and update the resolved market in real-time
                for (let i = 0; i < allMarkets.length; i++) {
                    const event = allMarkets[i];
                    for (let j = 0; j < event.markets.length; j++) {
                        if (event.markets[j].id === data.marketId) {
                            // Update market status to resolved
                            event.markets[j].status = 'resolved';
                            event.activeMarketsCount = data.eventData.activeMarketsCount;
                            event.resolvedMarketsCount = data.eventData.resolvedMarketsCount;
                            
                            console.log(`üî¥ Market resolved in real-time: ${data.market.question}`);
                            
                            // Show notification
                            showRealtimeNotification(`Market resolved: ${data.market.question}`);
                            
                            // Refresh display immediately
                            displayMarkets(sortEvents(allMarkets));
                            loadStats();
                            updateCountdowns();
                            break;
                        }
                    }
                }
            } else if (data.type === 'price_update') {
                // Handle price updates if needed
                console.log(`üíπ Price update: Market ${data.marketId} - $${data.price}`);
            }
        }

        function showRealtimeNotification(message) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc3545;
                color: white;
                padding: 15px;
                border-radius: 5px;
                z-index: 1000;
                max-width: 300px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            notification.textContent = `üî¥ REAL-TIME: ${message}`;
            
            document.body.appendChild(notification);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }

        // Auto-refresh every 5 minutes with synchronized countdown (all users see same countdown)
        let nextUpdateTime = null;
        let countdownInterval = null;
        let isRefreshing = false;
        
        function startAutoRefresh() {
            // Calculate next synchronized 5-minute interval (:00, :05, :10, :15, etc.)
            const now = new Date();
            const currentMinutes = now.getMinutes();
            const currentSeconds = now.getSeconds();
            const currentMs = now.getMilliseconds();
            
            // Round up to next 5-minute mark
            const nextInterval = Math.ceil(currentMinutes / 5) * 5;
            const nextMinutes = nextInterval % 60;
            const hoursToAdd = nextInterval >= 60 ? 1 : 0;
            
            nextUpdateTime = new Date(now);
            nextUpdateTime.setHours(now.getHours() + hoursToAdd);
            nextUpdateTime.setMinutes(nextMinutes);
            nextUpdateTime.setSeconds(0);
            nextUpdateTime.setMilliseconds(0);
            
            // If we're already at the exact minute boundary, move to next interval
            if (currentSeconds === 0 && currentMs < 100) {
                nextUpdateTime.setMinutes(nextUpdateTime.getMinutes() + 5);
            }
            
            updateCountdownDisplay();
        }
        
        function updateCountdownDisplay() {
            if (!nextUpdateTime) return;
            
            const now = new Date();
            const timeLeft = nextUpdateTime - now;
            
            if (timeLeft <= 0) {
                if (!isRefreshing) {
                    isRefreshing = true;
                    document.getElementById('countdownTimer').textContent = '‚è∞ Updating now...';
                    
                    // Perform refresh asynchronously to avoid blocking
                    performScheduledRefresh();
                }
                return;
            }
            
            const minutes = Math.floor(timeLeft / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
            
            document.getElementById('countdownTimer').textContent = 
                `‚è∞ Next update in: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        async function performScheduledRefresh() {
            try {
                // Perform both operations in parallel for better performance
                await Promise.all([
                    loadStats(),
                    loadMarkets()
                ]);
                
                // Wait a moment to show the "Updating now..." message
                setTimeout(() => {
                    isRefreshing = false;
                    startAutoRefresh();
                }, 1000);
                
            } catch (error) {
                console.error('Error during scheduled refresh:', error);
                // Reset the refresh lock and restart even if there was an error
                setTimeout(() => {
                    isRefreshing = false;
                    startAutoRefresh();
                }, 2000);
            }
        }
        
        // Update countdown every second
        setInterval(updateCountdownDisplay, 1000);

        // Winner tracking functionality
        let isWinnerView = false;

        function toggleWinnerView() {
            isWinnerView = !isWinnerView;
            
            const regularStats = document.getElementById('stats');
            const winnerStats = document.getElementById('winnerStats');
            const button = document.querySelector('button[onclick="toggleWinnerView()"]');
            
            if (isWinnerView) {
                regularStats.style.display = 'none';
                winnerStats.style.display = 'flex';
                button.textContent = 'üìä Markets';
                button.style.backgroundColor = '#6c757d';
                loadWinnerStats();
            } else {
                regularStats.style.display = 'flex';
                winnerStats.style.display = 'none';
                button.textContent = 'üèÜ Winners';
                button.style.backgroundColor = '#28a745';
                loadStats();
            }
        }

        async function loadWinnerStats() {
            try {
                const response = await fetch('/winner-stats');
                const stats = await response.json();
                
                document.getElementById('totalWinners').textContent = stats.totalWinners.toLocaleString();
                document.getElementById('totalPayouts').textContent = `$${stats.totalPayouts.toLocaleString()}`;
                document.getElementById('marketsTracked').textContent = stats.totalMarketsTracked.toLocaleString();
                
                if (stats.topWinner) {
                    const winnerText = `${formatAddress(stats.topWinner.address)} - $${stats.topWinner.payoutUSDC.toLocaleString()}`;
                    document.getElementById('topWinner').textContent = winnerText;
                } else {
                    document.getElementById('topWinner').textContent = 'No data';
                }
                
            } catch (error) {
                console.error('Error loading winner stats:', error);
                document.getElementById('totalWinners').textContent = 'Error';
                document.getElementById('totalPayouts').textContent = 'Error';
                document.getElementById('marketsTracked').textContent = 'Error';
                document.getElementById('topWinner').textContent = 'Error';
            }
        }

        function formatAddress(address) {
            if (!address) return 'Unknown';
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        function showMarketIds() {
            if (!allMarkets || allMarkets.length === 0) {
                alert('No markets loaded yet. Please refresh first.');
                return;
            }

            let idsText = 'üìã MARKET IDs FOR WINNER TRACKING\n\n';
            idsText += '==== EVENT IDs ====\n';
            
            allMarkets.forEach(event => {
                idsText += `Event: ${event.title}\n`;
                idsText += `ID: ${event.id || 'N/A'}\n`;
                idsText += `Slug: ${event.slug || 'N/A'}\n\n`;
            });

            idsText += '\n==== INDIVIDUAL MARKET IDs ====\n';
            
            allMarkets.forEach(event => {
                if (event.markets && event.markets.length > 0) {
                    idsText += `\n--- ${event.title} ---\n`;
                    event.markets.forEach((market, index) => {
                        const isResolved = market.active === false || market.closed === true;
                        idsText += `${index + 1}. ${market.question}\n`;
                        idsText += `   ID: ${market.id || market.conditionId || 'N/A'}\n`;
                        idsText += `   Status: ${isResolved ? 'üèÜ RESOLVED' : '‚è≥ Active'}\n`;
                        if (isResolved) {
                            if (market.winningOutcome) {
                                idsText += `   üèÜ Winner: ${market.winningOutcome}\n`;
                            }
                            idsText += `   Track Winners: /track-winners?marketId=${market.id}&outcome=${market.winningOutcome || '<YES/NO>'}\n`;
                        }
                        idsText += '\n';
                    });
                }
            });

            idsText += '\n==== USAGE EXAMPLES ====\n';
            idsText += 'GET /track-winners?marketId=MARKET_ID&outcome=YES\n';
            idsText += 'GET /track-winners?marketId=MARKET_ID&outcome=NO\n';
            idsText += 'GET /winners?marketId=MARKET_ID\n';
            idsText += 'GET /winners?limit=50  (top winners across all markets)\n';

            // Create a modal-like display
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 10px;
                max-width: 90%;
                max-height: 90%;
                overflow: auto;
                position: relative;
            `;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï Close';
            closeBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: #dc3545;
                color: white;
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
            `;
            closeBtn.onclick = () => document.body.removeChild(modal);

            const textarea = document.createElement('textarea');
            textarea.value = idsText;
            textarea.style.cssText = `
                width: 100%;
                height: 500px;
                font-family: monospace;
                font-size: 12px;
                border: 1px solid #ddd;
                padding: 10px;
                margin-top: 30px;
            `;
            textarea.readOnly = true;

            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'üìã Copy All';
            copyBtn.style.cssText = `
                margin-top: 10px;
                background: #28a745;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
                cursor: pointer;
            `;
            copyBtn.onclick = () => {
                textarea.select();
                document.execCommand('copy');
                copyBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => copyBtn.textContent = 'üìã Copy All', 2000);
            };

            content.appendChild(closeBtn);
            content.appendChild(textarea);
            content.appendChild(copyBtn);
            modal.appendChild(content);
            document.body.appendChild(modal);

            // Close on background click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
        }

        // Update countdowns every second
        setInterval(updateCountdowns, 1000);

        // Initial load
        loadStats();
        loadMarkets();
        startAutoRefresh();
        
        // Connect to real-time updates
        connectToSSE();
    </script>
</body>
</html>